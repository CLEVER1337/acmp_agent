
def main():
    import sys
    data = sys.stdin.read().split()
    if not data:
        print("Crisis")
        return
        
    n = int(data[0])
    m = int(data[1])
    k = int(data[2])
    
    prefs = []
    index = 3
    for i in range(n):
        row = list(map(int, data[index:index+k]))
        index += k
        prefs.append(row)
    
    # Создаем обратное отображение: для каждого депутата и каждого законопроекта - его ранг
    rank = [[0] * (k+1) for _ in range(n)]
    for i in range(n):
        for j in range(k):
            bill = prefs[i][j]
            rank[i][bill] = j
    
    # Функция для проверки, может ли законопроект x быть принят
    def can_pass(x):
        # votes[i] = True если депутат i голосует за x
        votes = [False] * n
        for i in range(n):
            # Депутат голосует за x, если x предпочтительнее любого законопроекта, который может пройти после x
            # Но поскольку мы проверяем конкретный x, то депутат будет голосовать за x, если x предпочтительнее его "резервного" варианта
            
            # Находим самый предпочтительный законопроект, который может пройти после x
            best_after = k + 1
            for j in range(rank[i][x] + 1, k):
                candidate = prefs[i][j]
                if candidate <= x:  # рассматриваем только те, что идут после x в порядке обсуждения
                    continue
                # Проверяем, может ли candidate пройти при условии, что x уже провалился
                # Но это рекурсивно, поэтому используем динамическое программирование
                # Вместо этого используем тот факт, что депутат знает исходы
                pass
            # Упрощенный подход: депутат голосует за x, если x предпочтительнее кризиса
            # и если x предпочтительнее любого законопроекта, который может пройти после x
            # Но поскольку это сложно, используем стандартный подход для таких задач:
            
            # Альтернативный подход: депутат голосует за x, если x предпочтительнее исхода, который наступит, если x не пройдет
            # Это требует знания исхода для оставшихся законопроектов
            pass
        
        # Упрощенный подход: считаем, что депутат голосует за x, если x предпочтительнее кризиса
        # и если нет законопроекта после x, который предпочтительнее и может пройти
        # Но это циклично
        
        # Используем стандартное решение для "итеративного удаления доминируемых стратегий"
        # Начинаем с последнего законопроекта и идем назад
        
        # Вместо этого реализуем обратный проход
        pass
    
    # Стандартное решение для таких задач - обратный проход от последнего законопроекта
    # outcome[i] - исход для законопроектов начиная с i-го
    outcome = [None] * (k+2)
    outcome[k+1] = "Crisis"  # если законопроектов нет
    
    # Для каждого законопроекта с k до 1 определяем, пройдет ли он
    for x in range(k, 0, -1):
        # Считаем голоса за x
        votes_count = 0
        for i in range(n):
            # Депутат i голосует за x, если x предпочтительнее исхода для законопроектов после x
            # outcome_after - исход если x не пройдет
            outcome_after = outcome[x+1] if x < k else "Crisis"
            
            if outcome_after == "Crisis":
                # Депутат предпочтет любой законопроект кризису
                votes_count += 1
            else:
                # Сравниваем ранг x и outcome_after
                rank_x = rank[i][x]
                rank_outcome = rank[i][outcome_after]
                if rank_x < rank_outcome:  # x предпочтительнее
                    votes_count += 1
        
        if votes_count >= m:
            outcome[x] = x
        else:
            outcome[x] = outcome[x+1]
    
    result = outcome[1]
    if result == "Crisis":
        print("Crisis")
    else:
        print(result)

if __name__ == "__main__":
    main()
